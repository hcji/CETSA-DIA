# -*- coding: utf-8 -*-
"""
Created on Tue Dec 31 09:14:11 2019

@author: hcji
"""

import pymzml
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow.compat.v1 as tf
from tqdm import tqdm
from scipy import signal
from bisect import bisect_left, bisect_right
from prosit import model
from prosit import prediction
from prosit import constants
from prosit import tensorize
from seq_encode.ms import ms_to_vec


def load_data(mzml, swath):
    """
    Load raw ms file and SWATH window.
    
    Parameters
    ----------
    mzml : str
        The path of the ms file. Only *.mzml support mzml, other format can be
        converted by ProteoWizard. Note: the peaks should be in centroid mode.
    swath : str
        The path of the SWTAH window file. Shold be *.csv format. Include columns: 
        'start_mz', 'end_mz', 'center'.
    """
    
    window = pd.read_csv(swath)
    precursors = np.array([-1.0] + list(window['center']))
    reader = pymzml.run.Reader(mzml)
    all_peaks = []
    all_rts = []
    for p in reader:
        all_rts.append(p.scan_time[0])
        all_peaks.append(p)
    all_rts = np.array(all_rts)
    all_peaks = np.array(all_peaks)
    return {'rts': all_rts,
            'precursors': precursors,
            'window': window,
            'peaks': all_peaks}


def predict_library(peplist):
    """
    Predict iRT and MS/MS by prosit package:
        https://github.com/kusterlab/prosit
    
    Parameters
    ----------
    peplist : str
        The path of the peptide list file. Shold be *.csv format. Include columns: 
        'modified_sequence', 'collision_energy', 'precursor_charge'.
    """
    pep = pd.read_csv(peplist)
    pept = tensorize.csv(pep)
    d_spectra = {}
    d_irt = {}

    d_spectra["graph"] = tf.Graph()
    with d_spectra["graph"].as_default():
        d_spectra["session"] = tf.Session()
        with d_spectra["session"].as_default():
            d_spectra["model"], d_spectra["config"] = model.load(
                'prosit/model/fragmentation_prediction',
                trained=True)
            d_spectra["model"].compile(optimizer="adam", loss="mse")
            
    d_irt["graph"] = tf.Graph()
    with d_irt["graph"].as_default():
        d_irt["session"] = tf.Session()
        with d_irt["session"].as_default():
            d_irt["model"], d_irt["config"] = model.load(
                'prosit/model/irt_prediction',
                trained=True)
            d_irt["model"].compile(optimizer="adam", loss="mse")
            
    pept = prediction.predict(pept, d_irt)
    pept = prediction.predict(pept, d_spectra)
    
    output = {}
    for i in range(len(pep)):
        n = pep['modified_sequence'][i] + '_'
        n += str(pep['collision_energy'][i]) + 'NCE_'
        n += str(pep['precursor_charge'][i]) + '+'
        irt = pept['iRT'][i][0]
        mz = pept['masses_pred'][i]
        abund = pept['intensities_pred'][i]
        keep = np.where(abund > 0.01)[0]
        mz = mz[keep]
        abund = abund[keep]
        od = np.argsort(mz)
        mz = mz[od]
        abund = abund[od]
        
        seq = pept['sequence_integer'][i]
        mw = 0
        for s in seq:
            if s == 0:
                break
            aa = list(constants.ALPHABET.keys())[list(constants.ALPHABET.values()).index(s)]
            mw += constants.AMINO_ACID[aa]
        precursor = (mw + constants.H2O + constants.PROTON * pep['precursor_charge'][i]) / pep['precursor_charge'][i]
        
        output[n] = {'irt': irt, 'mz': mz, 'intensity': abund, 'precursor': precursor}
    return output
    

def precursor_eic(data, library, mztol=0.05, rtlength=5):
    """
    Get extracted ion profile of the targeted peptide precursor
    
    Parameters
    ----------
    data : dict
        The results returned by the *load_data* function.
    library : dict
        The library generated by the *predict_library* function.
    """
    
    ind = np.arange(0, len(data['peaks']), len(data['precursors']))
    peaks = data['peaks'][ind]
    eics = {}
    for i in library.keys():
        exmz = library[i]['precursor']
        mzrange = [exmz - mztol, exmz + mztol]
        if 'corrected_rt' in library[i]:
            exrt = library[i]['precursor']
            rtrange = [exrt - rtlength, exrt + rtlength]
        else:
            rtrange = [0, float('inf')]
            
        rts, abunds = [], []
        for p in peaks:
            if p.scan_time[0] > rtrange[1]:
                break
            if (p.scan_time[0] >= rtrange[0]) and (p.scan_time[0] <= rtrange[1]) and (p.ms_level==1):
                rts.append(p.scan_time[0])
                mzs, intensities = p.centroidedPeaks[:,0], p.centroidedPeaks[:,1]
                sel_peaks = np.arange(bisect_left(mzs, mzrange[0]), bisect_right(mzs, mzrange[1]))
                abunds.append(np.sum(intensities[sel_peaks]))
            # plt.plot(rts, abunds)
        eics[i] = {'rt': rts, 'intensity': abunds}
    return eics


def get_ms2(data, exmz, exrt):
    """
    Get the ms/ms spectrum of a targeted scan and SWATH window.
    
    Parameters
    ----------
    data : dict
        The results returned by the *load_data* function.
    exmz : float
        The targeted precursor located in a SWATH window.
    exrt : list
        A list of the targeted retention time.
    """
    window = data['window']
    wid = np.where(np.logical_and(window['start_mz'] < exmz , window['end_mz'] > exmz))[0][0] + 1
    ind1 = np.arange(wid, len(data['peaks']), len(data['precursors']))
    
    output = {}
    rts = data['rts'][ind1]
    for r in exrt:    
        rid = np.argmin(np.abs(rts - r))
        peak = data['peaks'][ind1[rid]].centroidedPeaks
        output[str(r)] = peak
    return output
    

def irt_curve(data, irtlib, irteic, mscor=0.9):
    """
    Get the calibration curve based on the iRT peptides
    
    Parameters
    ----------
    data : dict
        The results returned by the *load_data* function.
    irtlib : dict
        The iRT peptide library generated by the *predict_library* function.
    mscor : float
        The threshold of ms/ms similairty between the ms in library and the ms in raw data.
    """
    for i in range(len(irteic)):
        k = list(irteic.keys())[i]
        eic = irteic[k]
        rts = np.array(eic['rt'])
        intensities = np.array(eic['intensity'])
        pks = signal.find_peaks(intensities, width = 2, height = np.percentile(intensities, 90))[0]
        exrt = rts[pks]
        exmz = irtlib[k]['precursor']
        fragms = np.array([irtlib[k]['mz'], irtlib[k]['intensity']]).transpose()
    


def fragment_eic(data, library, mztol=0.05, rtlength=30):
    precursor = precursors[np.argmin(np.abs(precursors - exmz))]
    rts, abunds = [], []
    mzrange = [fragmz - mztol, fragmz + mztol]
    rtrange = [exrt - rtlength, exrt + rtlength]    
    for p in peaks:
        if p.scan_time[0] > rtrange[1]:
            break
        if (p.scan_time[0] >= rtrange[0]) and (p.scan_time[0] <= rtrange[1]) and (p.ms_level > 1):
            if abs(p.selected_precursors[0]['mz'] - precursor) < 1:
                rts.append(p.scan_time[0])
                mzs, intensities = p.centroidedPeaks[:,0], p.centroidedPeaks[:,1]
                sel_peaks = np.arange(bisect_left(mzs, mzrange[0]), bisect_right(mzs, mzrange[1]))
                abunds.append(np.sum(intensities[sel_peaks])) 
    # plt.plot(rts, abunds)
    return rts, abunds


def get_ms2(peaks, precursors, exmz, exrt):
    precursor = precursors[np.argmin(np.abs(precursors - exmz))]
    nearest = 10**6
    ms2 = None
    for p in peaks:
        if (abs(exrt - p.scan_time[0]) < nearest) and (p.ms_level==2):
            if p.selected_precursors[0]['mz'] == precursor:
                ms2 = (p.centroidedPeaks[:,0], p.centroidedPeaks[:,1])
                nearest = abs(exrt - p.scan_time[0])
    return ms2


def plot_ms(spectrum):
    plt.figure(figsize=(6, 4), dpi=300)
    plt.vlines(spectrum['mz'], np.zeros(spectrum.shape[0]), np.array(spectrum['intensity']), 'red') 
    plt.axhline(0, color='black')
    plt.xlabel('m/z')
    plt.ylabel('Relative Intensity')
    plt.show()
    
    
def plot_anno_ms(spectrum, mzs, annotations, tol=0.1):
    spectrum = pd.DataFrame(spectrum)
    spectrum.columns = ['mz', 'intensity']
    spectrum['intensity'] /= max(spectrum['intensity'])
    c_mz, c_int, c_ann = [], [], []
    for i, mz in enumerate(mzs):
        diffs = abs(spectrum['mz'] - mz)
        if min(diffs) < tol:
            c_mz.append(spectrum['mz'][np.argmin(diffs)])
            c_int.append(spectrum['intensity'][np.argmin(diffs)])
            c_ann.append(annotations[i])
    plt.figure(figsize=(6, 4), dpi=300)
    plt.vlines(spectrum['mz'], np.zeros(spectrum.shape[0]), np.array(spectrum['intensity']), 'gray')
    plt.vlines(c_mz, np.zeros(len(c_mz)), c_int, 'red')
    for i in range(len(c_mz)):
        plt.text(c_mz[i], c_int[i]+0.025, c_ann[i], color='red', rotation='vertical')
    plt.axhline(0, color='black')
    plt.xlabel('m/z')
    plt.ylabel('Relative Intensity')
    plt.show()
    


def plot_compare_ms(spectrum1, spectrum2, tol=0.5):
    spectrum1 = pd.DataFrame(spectrum1)
    spectrum2 = pd.DataFrame(spectrum2)
    spectrum1.columns = ['mz', 'intensity']
    spectrum2.columns = ['mz', 'intensity']
    spectrum1['intensity'] /= np.max(spectrum1['intensity'])
    spectrum2['intensity'] /= np.max(spectrum2['intensity'])
    c_mz = []
    c_int = []
    for i in spectrum1.index:
        diffs = abs(spectrum2['mz'] - spectrum1['mz'][i])
        if min(diffs) < tol:
            c_mz.append(spectrum1['mz'][i])
            c_mz.append(spectrum2['mz'][np.argmin(diffs)])
            c_int.append(spectrum1['intensity'][i])
            c_int.append(-spectrum2['intensity'][np.argmin(diffs)])
    c_spec = pd.DataFrame({'mz':c_mz, 'intensity':c_int}) 
    plt.figure(figsize=(6, 6), dpi=300)
    plt.vlines(spectrum1['mz'], np.zeros(spectrum1.shape[0]), np.array(spectrum1['intensity']), 'gray')
    plt.axhline(0, color='black')
    plt.vlines(spectrum2['mz'], np.zeros(spectrum2.shape[0]), -np.array(spectrum2['intensity']), 'gray')
    plt.vlines(c_spec['mz'], np.zeros(c_spec.shape[0]), c_spec['intensity'], 'red')
    plt.xlabel('m/z')
    plt.ylabel('Relative Intensity')
    plt.show()



